generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                            String            @id @default(cuid())
  createdAt                     DateTime          @default(now())
  updatedAt                     DateTime          @updatedAt
  email                         String            @unique
  emailVerified                 Boolean           @default(false)
  name                          String
  image                         String?
  locale                        String?           @default("fr")
  theme                         String?           @default("system")
  emailNotifications            Boolean           @default(true)
  lastPasswordResetRequestAt    DateTime?
  passwordResetRequestCount     Int               @default(0)
  passwordResetRequestResetAt   DateTime?
  healthDataConsentGrantedAt   DateTime?
  role                          UserRole          @default(USER)
  accounts                      Account[]
  sessions                      Session[]
  exerciseAttempts              ExerciseAttempt[]
  consentHistory                ConsentHistory[]
  patientAssociations           PatientProviderAssociation[] @relation("PatientAssociations")
  providerAssociations          PatientProviderAssociation[] @relation("ProviderAssociations")
  sentMessages                  ProviderPatientMessage[] @relation("SentMessages")
  badges                        UserBadge[]
  streakData                    StreakData?
}

enum UserRole {
  USER
  ADMIN
  HEALTHCARE_PROVIDER
}

model Account {
  id                    String    @id @default(cuid())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  providerId            String
  accountId             String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Session {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Verification {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  value      String
  expiresAt  DateTime
  identifier String
  tokenId       String?   @unique
  ipAddress     String?
  userAgent     String?
  attempts      Int       @default(0)
  lastAttemptAt DateTime?

  @@unique([identifier, value])
  @@index([identifier])
}

model ExerciseAttempt {
  id           String   @id @default(cuid())
  exerciseSlug String
  userId       String
  score        Float?
  duration     Int?
  data         Json?
  completedAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, completedAt])
  @@index([exerciseSlug])
}

enum ConsentType {
  HEALTH_DATA
}

model ConsentHistory {
  id           String      @id @default(cuid())
  userId       String
  consentType  ConsentType
  granted      Boolean
  grantedAt    DateTime    @default(now())
  ipAddress    String?
  userAgent    String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, grantedAt])
}

model PatientProviderAssociation {
  id                  String   @id @default(cuid())
  patientId           String
  providerId          String
  status              AssociationStatus @default(PENDING)
  invitationToken     String?  @unique
  invitationSentAt    DateTime?
  acceptedAt          DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  patient             User @relation("PatientAssociations", fields: [patientId], references: [id], onDelete: Cascade)
  provider            User @relation("ProviderAssociations", fields: [providerId], references: [id], onDelete: Cascade)
  messages            ProviderPatientMessage[]
  
  @@unique([patientId, providerId])
  @@index([providerId, status])
  @@index([invitationToken])
}

enum AssociationStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

model ProviderPatientMessage {
  id              String   @id @default(cuid())
  associationId   String
  senderId        String
  content         String
  read            Boolean  @default(false)
  createdAt       DateTime @default(now())
  
  association     PatientProviderAssociation @relation(fields: [associationId], references: [id], onDelete: Cascade)
  sender          User @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  
  @@index([associationId, createdAt])
  @@index([senderId])
}

enum BadgeType {
  WELCOME           // Badge d'inscription
  FIRST_EXERCISE    // Premier exercice complété
  STREAK_3          // 3 jours consécutifs
  STREAK_7          // 7 jours consécutifs
  STREAK_14         // 14 jours consécutifs
  STREAK_30         // 30 jours consécutifs
  STREAK_60         // 60 jours consécutifs
  STREAK_100        // 100 jours consécutifs
  VOLUME_10         // 10 exercices
  VOLUME_25         // 25 exercices
  VOLUME_50         // 50 exercices
  VOLUME_100        // 100 exercices
  VOLUME_250        // 250 exercices
  VOLUME_500        // 500 exercices
  VOLUME_1000       // 1000 exercices
}

model UserBadge {
  id          String    @id @default(cuid())
  userId      String
  badgeType   BadgeType
  earnedAt    DateTime  @default(now())
  
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeType])
  @@index([userId, earnedAt])
}

model StreakData {
  id                    String   @id @default(cuid())
  userId                String   @unique
  currentStreak         Int      @default(0)
  longestStreak         Int      @default(0)
  lastExerciseDate      DateTime?
  lastBreakDate         DateTime?
  
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}
